CODESG SEGMENT PARA 'CODE'
    BEGIN PROC FAR
        ASSUME CS:CODESG, SS:STACKSG, DS:DATASG, ES:DATASG
PUSH DS

SUB AX, AX

PUSH AX

MOV AX, DATASG

MOV DS, AX

MOV ES, AX


; input message: enter c

MOV AX, 0900H

LEA DX, MESSAGE1

INT 21H


; input c

CALL INPUT_NUMBER

MOV AX, BIN_VALUE

MOV NUMBER_C, AX


CALL COUT_ENDL


; input message: enter d

MOV AX, 0900H

LEA DX, MESSAGE2

INT 21H


; input d

CALL INPUT_NUMBER

MOV AX, BIN_VALUE

MOV NUMBER_D, AX

CALL COUT_ENDL


; input message: enter array

MOV AX, 0900H

LEA DX, MESSAGE_ARR

INT 21H


CALL COUT_ENDL


MOV CX, bN ; 5

XOR BX, BX


INP:

CALL INPUT_NUMBER

MOV AX, BIN_VALUE

CALL COUT_ENDL

MOV NUMBERS[BX], AX

INC BX

INC BX


LOOP INP


MOV CX, bN

CALL LAB4

MOV AX, 0900H
        LEA DX, RESULT_MESSAGE ; Добавлено сообщение перед результатом
        INT 21H

        LEA SI, RESULT + RESULT_SIZE - 1 ; Указываем на конец буфера
        CALL BIN_TO_ASCII

        MOV AX, 0900H
        LEA DX, RESULT
        INT 21H

    EXIT:
        MOV AX, 4C00H
        INT 21H
        RET
    BEGIN ENDP

    LAB4 PROC NEAR
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH SI
    PUSH DI

    MOV AX, 1          ; Инициализируем AX значением 1 для произведения
    MOV SI, 0          ; Инициализируем SI как индекс массива
    MOV CX, bN         ; Устанавливаем количество элементов для обработки

DO_LOOP:
    MOV BX, NUMBERS[SI] ; Загружаем текущий элемент массива в BX

    ; Проверяем, находится ли BX в диапазоне [NUMBER_C, NUMBER_D]
    CMP BX, NUMBER_C
    JL NEXT_ELEMENT
    CMP BX, NUMBER_D
    JG NEXT_ELEMENT
    CMP BX, 0
    JL NEXT_ELEMENT

    MUL BX              ; Умножаем AX на BX. Результат в DX:AX
    ; Проверка на переполнение может быть добавлена здесь при необходимости
    ; Для простоты предполагаем, что переполнение не происходит

    ; В данном случае сохраняем результат обратно в AX
    ; Если необходимо учитывать переполнение, можно использовать DX

NEXT_ELEMENT:
    ADD SI, 2           ; Переходим к следующему элементу массива
    LOOP DO_LOOP        ; Повторяем цикл до окончания CX

    MOV BIN_VALUE, AX   ; Сохраняем результат произведения в BIN_VALUE

    POP DI
    POP SI
    POP CX
    POP BX
    POP AX
    RET
LAB4 ENDP



COUT_ENDL PROC NEAR

PUSH AX

PUSH DX

MOV AH, 09

LEA DX, ENDLINE

INT 21H

POP DX

POP AX

RET

COUT_ENDL ENDP


INPUT_NUMBER PROC NEAR

PUSH AX

PUSH BX

PUSH CX

PUSH DX

PUSH DI

PUSH SI

JMP NORMAL

MESSAGE_ERROR_LABEL:

CALL COUT_ENDL

MOV AX, 0900H

LEA DX, INPUT_ERROR_MESSAGE

INT 21H

NORMAL:

MOV MULT10, 1

MOV BIN_VALUE, 0

MOV AX, 0A00H

LEA DX, IPARAM

INT 21H


LEA SI, FIELD - 1

MOV BH, 0

MOV BL, ASCLEN


CALL IS_NUMBER

JNZ MESSAGE_ERROR_LABEL


CALL ASCII_TO_BIN

POP SI

POP DI

POP DX

POP CX

POP BX

POP AX

RET

INPUT_NUMBER ENDP



ASCII_TO_BIN PROC NEAR

PUSH AX

PUSH BX

PUSH CX

PUSH DX

PUSH DI

PUSH SI

MOV CX, 10

MOV DX, BX ; SAVE LEN TO DX

MOV BX, 1

MOV AL, [SI + BX]

MOV BX, DX

XOR DX, DX

MOV DI, BX ; DI = BX

CMP AL, '-' ; AL IS MINUS?

JNE B20 ; NO

DEC DI ; YES

B20:

MOV AL, [SI + BX]

AND AX, 000FH

MUL MULT10

ADD BIN_VALUE, AX

MOV AX, MULT10

MUL CX

MOV MULT10, AX

DEC BX

DEC DI

JNZ B20


CMP BX, DI ; IF BX == DI

JE END_B ; NO MINUS

; ELSE MINUS:

MOV AX, BIN_VALUE

NEG AX

MOV BIN_VALUE, AX

END_B:

POP SI

POP DI

POP DX

POP CX

POP BX

POP AX

RET

ASCII_TO_BIN ENDP


IS_NUMBER PROC NEAR

PUSH AX

PUSH BX

PUSH CX

PUSH DX

PUSH DI

PUSH SI

MOV CX, BX ; SAVE LEN IN CX

MOV BX, 1 ; BX = 1

MOV AL, [SI + BX] ; AL = (CHAR)

CMP AL, '-' ; AL IS MINUS?

MOV BX, CX ; LEN IN BX

; NO - JUMP

JNE IS_NUM

; YES:

DEC CX

IS_NUM:

MOV AL, [SI + BX]

CMP AL, '0'

JB ERROR_N

CMP AL, '9'

JA ERROR_N

DEC BX

DEC CX

JNZ IS_NUM

JMP BRANCHI

ERROR_N:

STC

BRANCHI:

POP SI

POP DI

POP DX

POP CX

POP BX

POP AX

RET

IS_NUMBER ENDP


BIN_TO_ASCII PROC NEAR
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH SI
        PUSH DI

        MOV CX, 10
        LEA SI, RESULT + RESULT_SIZE - 2 ; Начинаем с конца -2, чтобы оставить место для знака и нуль-терминатора
        MOV BYTE PTR [SI+1], '$' ; Нуль-терминируем строку
        MOV AX, BIN_VALUE
        JS negative ; Проверяем на отрицательное число

positive:
        XOR DX, DX
        DIV CX
        ADD DL, '0'
        MOV [SI], DL
        DEC SI
        TEST AX, AX
        JNZ positive
        JMP end_conversion

negative:
        NEG AX
        MOV BYTE PTR [SI], '-'
        DEC SI
        JMP positive
        
end_conversion:

        POP DI
        POP SI
        POP DX
        POP CX
        POP BX
        POP AX
        RET
    BIN_TO_ASCII ENDP


CODESG ENDS

;---------------END CODE---------------


;-----------------STACK-----------------

STACKSG SEGMENT PARA STACK 'STACK'
    DW 128 DUP(?) ; Увеличен размер стека
STACKSG ENDS
;---------------END STACK---------------


;-----------------DATA-----------------

DATASG SEGMENT PARA 'DATA'

INPUT_ERROR_MESSAGE DB 'INCORRECT. $'

bN DW 5 ; Количество чисел

NUMBER_C DW 0

NUMBER_D DW 0

MESSAGE1 DB 'ENTER C: $'

MESSAGE2 DB 'ENTER D: $'

MESSAGE_ARR DB 'ENTER 5 ELEMENTS: $'

NUMBERS DW 5 DUP(0)

IPARAM LABEL BYTE

MAXLEN DB 20

ASCLEN DB ?

FIELD DB 20 DUP (' ')

MULT10 DW 1

BIN_VALUE DW 0

ENDLINE DB 13, 10, '$'

RESULT_MESSAGE DB 'Result: $' ; Сообщение перед результатом
    RESULT_SIZE EQU 10 ; Определяем размер буфера результата
    RESULT DB RESULT_SIZE DUP(' ') ; Увеличен размер буфера результата

DATASG ENDS

;---------------END DATA---------------


END BEGIN
